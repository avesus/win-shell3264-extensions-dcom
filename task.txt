1. Сервер реализации задач архивации CodexSrv
запускается в том же IL и под той же учёткой,
что и вызывающий процесс.

2. Когда требуется произвести с файлом операцию,
требующую элевации, запускается другой экземпляр сервера
с элевацией.

3. dll панели управления должна быть 64-битной,
т.к. explorer загружает её в своё адресное пространство.

MagicRAR Settings
Configure MagicRAR Plug-In Technology based data (de)compressio


ContextMenuHandlers:
MagicRAR: Extract
{A8F864A1-440C-11D6-A729-00002127B9F9}
	MagicRAR: Extract
	mCodexAPI.dll as InProcServer32

DropHandler
{E8B6E261-4594-11D6-A72A-00002127B9F9}
	MagicRAR: Drag-and-Drop
	mCodexAPI.dll as InProcServer32

PropertySheetHandlers
  MagicRAR: Property Sheet
    {8A1A763A-B9FC-4F6C-B96C-D2B487A642DD}
	MagicRAR: Property Sheet
	mCodexAPI.dll as InProcServer32


{
  IShellFolder
    IShellFolder2

  IPersist
    IPersistFolder
      IPersistFolder2

  IEnumIDList
}


Создать класс для обслуживания запросов на получение информации
об архивах.

Класс должен кешировать объекты ICodexArchive
и выдавать уже существующие объекты при запросе
имеющегося пути.

IShellFolder при вызове BindToObject() должен создавать
новый объект CArchiveFolders и передавать ему указатель на уже
полученный интерфейс ICodexArchive.

Дочерний объект строит полный путь и получает доступ только к файлам и
папкам, являющимися дочерними к нему.

ICodexArchive предоставляет список файлов и папок в рамках
заданного уровня ("родительской папки").

Заданный уровень указывается в методе запроса списка файлов и папок
в заданной папке:

ICodexArchive::GetItemsCount( WCHAR* i_pwzDir, UINT32* o_pnItems );

ICodexArchive::GetItems( WCHAR* i_pwzDir,
  CODEX_FILETREE_ITEM* o_poItems );

GetItems( L"./" ) - выдаёт список файлов и папок в архивном файле.
GetItems( L"./Install/" ) - выдаёт список файлов и папок в папке "Install"
архивного файла.
итд.

Для папок должно быть доступно поле date_modified, определяемое
по последней дате модификации самого свежего файла внутри этих папок.

ICodexArchive::Open( WCHAR* i_pwzArchiveFilePath )

ICodexArchive внутри при доступе Open() строит дерево элементов данного
архива.

ICodexArchive::Close() вызывается в менеджере доступа к объектам ICodexArchive
после таймаута неиспользования объекта, и только, когда ссылки на него отсутствуют.

Соответственно, вызов Release() из кода CArchiveFolders запрещён.
Освобождение используемого объекта необходимо делать с помощью
метода менеджера доступа к объектам ICodexArchive.

Менеджер доступа к архивам должен выгружать все объекты, которые он использует
при выгрузке библиотеки (DLL_PROCESS_DETACH).

Менеджер доступа получает путь к архивному файлу и путь внутри него и выдаёт
список элементов (по запросу - папок, файлов или и то и другое).

Менеджер доступа проверяет необходимость элевации путём временного открытия файла с заданными параметрами и, в случае необходимости элевации он автоматически
создаёт или пересоздаёт соответствующий объект ICodexArchive.

Необходимо обеспечить единый доступ к архивам в рамках всей ОС.

Менеджеру доступа в таком случае неплохо быть COM-сервером, получающим единый доступ
к одним и тем же файлам (не только в рамках процесса Explorer'а, но и в рамках всех процессов всех explorer'ов во всех пользовательских сессиях).

Оптимальная работа для него - в режиме системной службы.

Он, соответственно, создавая объекты ICodexArchive в отдельных процессах,
может создавать их сразу с системными привилегиями.

Стоит вопрос доступа к этому серверу из низкопривилегированных процессов.

С этим может возникнуть множество проблем, основная из которых
- противоречивость и сложность реализации GUI плагинов, которые должны
отображаться в рамках desktop station вызывающего процесса.

Поэтому лучше будет повозиться с правами доступа и обработкой
взаимных блокировок архивных файлов.

Можно привязаться на нотификацию изменений файла и перечитывать
информацию динамически.

Но следует помнить, что плагин в любое время может взять
эксклюзивный доступ к файлу, и другие процессы не смогут
получить к нему никакого доступа.

Мы можем подписаться на нотификации изменений в папке, в которой содержится
открытый архивный файл.

Соответственно, при изменениях в этом файле, клиенту будет отправляться
соответствующее сообщение.

Сам архивный файл может быть изменён, либо удалён, либо переименован.
В любом случае, IShellFolder должен пересоздаваться заново,
а подключение к процессу ICodexArchive должно прерываться.

По возможности нужно разработать такую схему, при которой
уничтожение IShellFolder'ов и переподключение к серверу
будут минимальными.

! в CodexAPI нет понятия пустой папки в архиве. Плагины возвращают только
файловое содержимое.

Плагины не будут видеть юникодные файлы в принципе.

Для маленьких архивов с юникодными именами можно создавать копию файла и работать с ней.

DragDrop для выделенных папок не будет распаковывать пустые папки, потому что
в CodexAPI нет понятия папки.

CodexAPI некорректно работает с датами в американском формате (полный сбой),
поэтому пока даты и время мы не будем запрашивать совсем.


Если в менеджере 0 объектов и таймаут вышел, менеджер может начать выгрузку модуля.
Но! Модуль может быть загружен вызовом LoadLibrary и выгрузка должна быть запрещена в этот момент.

В таком случае, после того, как клиентский код произведёт вызов,
библиотека должна будет переинициализироваться заново.

Если вызов уже идёт, то реакция на таймаут должна осуществляться через крит. секцию.

В одном внутреннем потоке происходит создание, разрушение и учёт таймаутов.

Сделать класс списка контейнеров в предположении однопоточной внутренней работы внутри
потока.

Класс позволяет делать 3 вещи:
1. Находить объект и выдавать, где он хранится.
2. Вынимать объект из списка.
3. Добавлять объект в указанный список.

Отдельно создавать интерфейс доступа
Отдельно открывать архив
- всё это в предположении однопоточного доступа внутри потока.

Отдельно инициализировать контейнер при его создании.

















